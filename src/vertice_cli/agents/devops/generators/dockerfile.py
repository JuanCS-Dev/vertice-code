"""
Dockerfile Generator - Production-grade, security-first Docker images.

Features:
- Multi-stage builds (minimal attack surface)
- Non-root user
- Distroless/slim base images
- Health checks
- No secrets in layers
"""

import logging
from typing import Any, Dict

from .base import BaseGenerator

logger = logging.getLogger(__name__)


# Stack templates for different languages/frameworks
DOCKER_TEMPLATES = {
    "python_fastapi": {
        "builder_image": "python:3.11-slim",
        "runtime_image": "python:3.11-slim",
        "install_cmd": "pip install --no-cache-dir -r requirements.txt",
        "cmd": '["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]',
    },
    "node_express": {
        "builder_image": "node:18-alpine",
        "runtime_image": "node:18-alpine",
        "install_cmd": "npm ci --only=production",
        "cmd": '["node", "server.js"]',
    },
    "go_api": {
        "builder_image": "golang:1.21-alpine",
        "runtime_image": "alpine:3.18",
        "install_cmd": "go build -o app .",
        "cmd": '["./app"]',
    },
}


class DockerfileGenerator(BaseGenerator):
    """Generate production-grade, multi-stage Dockerfiles."""

    @property
    def name(self) -> str:
        return "dockerfile"

    async def generate(self, task_request: str) -> Dict[str, Any]:
        """Generate Dockerfile based on task request."""
        logger.info("Generating production Dockerfile...")

        # Detect stack (simplified - would analyze project structure)
        stack = self._detect_stack(task_request)
        template = DOCKER_TEMPLATES.get(stack, DOCKER_TEMPLATES["python_fastapi"])

        dockerfile = self._build_dockerfile(template)

        return {
            "dockerfile": dockerfile,
            "stack": stack,
            "security_features": [
                "Multi-stage build",
                "Non-root user (UID 1000)",
                "Health check configured",
                "Minimal base image",
                "No secrets in layers",
            ],
        }

    def _detect_stack(self, request: str) -> str:
        """Detect stack from request."""
        request_lower = request.lower()
        if "node" in request_lower or "express" in request_lower:
            return "node_express"
        elif "go" in request_lower or "golang" in request_lower:
            return "go_api"
        return "python_fastapi"

    def _build_dockerfile(self, template: Dict[str, str]) -> str:
        """Build Dockerfile content from template."""
        return f"""# Multi-stage Dockerfile - Production Grade
# Generated by DevOpsAgent

# ============================================================================
# STAGE 1: Builder
# ============================================================================
FROM {template['builder_image']} AS builder

WORKDIR /build

# Copy dependency files first (cache optimization)
COPY requirements.txt ./

# Install dependencies
RUN {template['install_cmd']}

# Copy application code
COPY . .

# ============================================================================
# STAGE 2: Runtime (Minimal)
# ============================================================================
FROM {template['runtime_image']}

# Security: Create non-root user
RUN useradd -m -u 1000 appuser && \\
    mkdir -p /app && \\
    chown -R appuser:appuser /app

# Switch to non-root user
USER appuser
WORKDIR /app

# Copy artifacts from builder
COPY --from=builder --chown=appuser:appuser /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder --chown=appuser:appuser /build /app

# Environment
ENV PYTHONUNBUFFERED=1 \\
    PYTHONDONTWRITEBYTECODE=1 \\
    PORT=8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \\
  CMD curl -f http://localhost:$PORT/health || exit 1

# Expose port
EXPOSE $PORT

# Run application
CMD {template['cmd']}
"""
