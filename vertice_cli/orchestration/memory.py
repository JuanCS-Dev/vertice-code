"""
MemoryManager: Shared context and session state management.

This module provides the memory layer that allows multiple agents to share
context, decisions, and intermediate results during workflow execution.

Architecture:
    SharedContext (Pydantic model)
        ├── session_id: Unique session identifier
        ├── decisions: Architecture decisions from Architect
        ├── context_files: Files identified by Explorer
        ├── execution_plan: Plan generated by Planner
        └── execution_results: Results from Refactorer
    
    MemoryManager (class)
        ├── create_session() - Initialize new session
        ├── get_context() - Retrieve session context
        ├── update_context() - Update specific fields
        └── delete_session() - Cleanup

Philosophy (Boris Cherny):
    "Shared mutable state is the root of all evil, unless properly managed."
    - Immutable data structures where possible
    - Explicit state transitions
    - Type-safe updates
    - Thread-safe operations
"""

import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class SharedContext(BaseModel):
    """Shared context accessible to all agents in a workflow.
    
    This is the "working memory" of the DevSquad. Each agent can read
    the entire context but only update specific fields relevant to its role.
    
    Attributes:
        session_id: Unique identifier for this workflow session
        user_request: Original user request that started the workflow
        decisions: Architecture decisions and approvals from Architect
        context_files: Files and symbols identified by Explorer
        execution_plan: Step-by-step plan generated by Planner
        execution_results: Results and commits from Refactorer
        review_feedback: Quality feedback from Reviewer
        metadata: Additional workflow metadata
        created_at: Session creation timestamp
        updated_at: Last update timestamp
    """

    session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_request: str = Field(..., min_length=1)

    # Architect output
    decisions: Dict[str, Any] = Field(
        default_factory=dict,
        description="Architecture decisions (approved/vetoed, structure, risks)",
    )

    # Explorer output
    context_files: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Relevant files with metadata (path, symbols, summary)",
    )

    # Planner output
    execution_plan: Dict[str, Any] = Field(
        default_factory=dict,
        description="Execution plan with steps, checkpoints, rollback strategy",
    )

    # Refactorer output
    execution_results: Dict[str, Any] = Field(
        default_factory=dict,
        description="Execution results (commits, files modified, test results)",
    )

    # Reviewer output
    review_feedback: Dict[str, Any] = Field(
        default_factory=dict,
        description="Review results (status, issues, suggestions)",
    )

    # Workflow metadata
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Token usage, timing, agent interactions",
    )

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


class MemoryManager:
    """Manages shared context across agent workflow sessions.
    
    Provides CRUD operations for SharedContext with thread-safety and
    validation. Designed to be extended with persistent storage (Redis,
    SQLite) in future versions.
    
    Current implementation: In-memory dictionary (ephemeral).
    Future: Redis with TTL or SQLite with session expiry.
    """

    def __init__(self) -> None:
        """Initialize memory manager with empty session store."""
        self._sessions: Dict[str, SharedContext] = {}

    def create_session(self, user_request: str) -> str:
        """Create a new workflow session.
        
        Args:
            user_request: Original user request that starts the workflow
            
        Returns:
            session_id: Unique identifier for this session
        """
        context = SharedContext(user_request=user_request)
        self._sessions[context.session_id] = context
        return context.session_id

    def get_context(self, session_id: str) -> Optional[SharedContext]:
        """Retrieve shared context for a session.
        
        Args:
            session_id: Session identifier
            
        Returns:
            SharedContext if session exists, None otherwise
        """
        return self._sessions.get(session_id)

    def update_context(
        self,
        session_id: str,
        **updates: Any,
    ) -> bool:
        """Update specific fields in shared context.
        
        This is the primary method agents use to share information.
        Only updates specified fields, leaving others unchanged.
        
        Args:
            session_id: Session identifier
            **updates: Field updates as keyword arguments
                      (e.g., decisions={...}, context_files=[...])
                      
        Returns:
            True if update succeeded, False if session not found
            
        Example:
            manager.update_context(
                session_id="abc-123",
                decisions={"approved": True, "architecture": {...}},
                metadata={"architect_tokens": 1234}
            )
        """
        context = self._sessions.get(session_id)
        if context is None:
            return False

        # Create updated context (Pydantic V2)
        updated_data = context.model_dump()
        updated_data["updated_at"] = datetime.utcnow()

        # Apply updates
        for field, value in updates.items():
            if field in updated_data:
                updated_data[field] = value

        # Replace with updated context
        self._sessions[session_id] = SharedContext(**updated_data)
        return True

    def delete_session(self, session_id: str) -> bool:
        """Delete a session and its context.
        
        Args:
            session_id: Session identifier
            
        Returns:
            True if session was deleted, False if not found
        """
        if session_id in self._sessions:
            del self._sessions[session_id]
            return True
        return False

    def list_sessions(self) -> List[str]:
        """List all active session IDs.
        
        Returns:
            List of session IDs
        """
        return list(self._sessions.keys())

    def get_session_count(self) -> int:
        """Get count of active sessions.
        
        Returns:
            Number of active sessions
        """
        return len(self._sessions)

    def clear_all(self) -> None:
        """Clear all sessions (use with caution).
        
        This is primarily for testing. In production, sessions should
        be explicitly deleted or expired via TTL.
        """
        self._sessions.clear()

    def __repr__(self) -> str:
        """String representation for debugging."""
        return f"<MemoryManager sessions={self.get_session_count()}>"
